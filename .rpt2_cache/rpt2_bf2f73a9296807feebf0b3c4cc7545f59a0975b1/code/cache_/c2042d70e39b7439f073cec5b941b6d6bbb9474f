{"code":"export default class HappyGua {\r\n    constructor(options) {\r\n        this.canvas = null;\r\n        this.ctx = null;\r\n        this.wrapEle = null;\r\n        this.innerEle = null;\r\n        this.canvasW = 0;\r\n        this.canvasH = 0;\r\n        this.supportTouch = false;\r\n        this.events = [];\r\n        this.startEventHandler = null;\r\n        this.moveEventHandler = null;\r\n        this.endEventHandler = null;\r\n        this.defaultOptions = {\r\n            radius: 10,\r\n            coverColor: '#CCCCCC',\r\n            coverText: '',\r\n            coverPic: '',\r\n            ratio: .8\r\n        };\r\n        // const mergeOptions = Object.assign({}, this.defaultOptions, options);\r\n        this.init(options);\r\n    }\r\n    init(options) {\r\n        if (!isCanvasSupported()) {\r\n            throw new Error('对不起，当前浏览器不支持Canvas，无法使用本控件！');\r\n            return;\r\n        }\r\n        _forEach(arguments, item => {\r\n            if (typeof item === \"object\") {\r\n                for (var k in item) {\r\n                    if (k === 'callback' && typeof item[k] === 'function') {\r\n                        this.defaultOptions.callback = item[k].bind(this);\r\n                    }\r\n                    else {\r\n                        k in this.defaultOptions && (this.defaultOptions[k] = item[k]);\r\n                    }\r\n                }\r\n            }\r\n            else if (typeof item === \"function\") {\r\n                this.defaultOptions.callback = item.bind(this);\r\n            }\r\n        });\r\n        this.wrapEle = document.querySelector(options.ele);\r\n        this.innerEle = this.wrapEle.children[0];\r\n        if (!this.wrapEle || !this.innerEle)\r\n            return;\r\n        this.canvasH = this.wrapEle.clientHeight;\r\n        this.canvasW = this.wrapEle.clientWidth;\r\n        this.innerEle.style.opacity = 0;\r\n        this.createCanvas();\r\n        this.eventDetect();\r\n    }\r\n    createCanvas() {\r\n        this.canvas = document.createElement('canvas');\r\n        this.canvas.id = 'cover';\r\n        this.canvas.height = this.canvasH;\r\n        this.canvas.width = this.canvasW;\r\n        this.canvas.style.position = 'absolute';\r\n        this.canvas.style.top = 0;\r\n        this.ctx = this.canvas.getContext('2d');\r\n        if (this.defaultOptions.coverPic) {\r\n            let coverPic = new Image();\r\n            coverPic.src = this.defaultOptions.coverPic;\r\n            coverPic.onload = () => { this.ctx.drawImage(coverPic, 0, 0, this.canvas.width, this.canvas.height); };\r\n        }\r\n        else {\r\n            this.ctx.strokeStyle = '#888686';\r\n            this.ctx.fillText('刮开此涂层', this.canvas.width / 2, this.canvas.height / 2);\r\n            this.ctx.fillStyle = this.defaultOptions.coverColor;\r\n            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\r\n        }\r\n        this.wrapEle.appendChild(this.canvas);\r\n        this.innerEle.style.opacity = 1;\r\n    }\r\n    eventDetect() {\r\n        if ('ontouchstart' in window)\r\n            this.supportTouch = true;\r\n        this.events = this.supportTouch ? ['touchstart', 'touchmove', 'touchend'] : ['mousedown', 'mousemove', 'mouseup'];\r\n        this.listenStart();\r\n    }\r\n    listenStart() {\r\n        this.startEventHandler = _startHandler.bind(this);\r\n        this.canvas.addEventListener(this.events[0], this.startEventHandler, false);\r\n    }\r\n    clearAll() {\r\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n        this.canvas.removeEventListener(this.events[0], this.startEventHandler);\r\n        this.canvas.removeEventListener(this.events[1], this.moveEventHandler);\r\n        this.canvas.removeEventListener(this.events[2], this.endEventHandler);\r\n    }\r\n    ;\r\n    calcRatio(callback) {\r\n        var pixels = this.ctx.getImageData(0, 0, this.canvasW, this.canvasH);\r\n        var transPixels = [];\r\n        _forEach(pixels.data, function (item, i) {\r\n            var pixel = pixels.data[i + 3];\r\n            if (pixel === 0) {\r\n                transPixels.push(pixel);\r\n            }\r\n        });\r\n        if (transPixels.length / pixels.data.length > this.defaultOptions.ratio) {\r\n            callback && typeof callback === 'function' && callback();\r\n        }\r\n    }\r\n}\r\nfunction _forEach(items, callback) {\r\n    return Array.prototype.forEach.call(items, function (item, idx) {\r\n        callback(item, idx);\r\n    });\r\n}\r\nfunction isCanvasSupported() {\r\n    let ele = document.createElement('canvas');\r\n    return !!(ele.getContext && ele.getContext('2d'));\r\n}\r\nfunction _startHandler(e) {\r\n    e.preventDefault();\r\n    this.moveEventHandler = _moveHandler.bind(this);\r\n    this.canvas.addEventListener(this.events[1], this.moveEventHandler, false);\r\n    this.endEventHandler = _endHandler.bind(this);\r\n    document.addEventListener(this.events[2], this.endEventHandler, false);\r\n}\r\n;\r\nfunction _moveHandler(e) {\r\n    e.preventDefault();\r\n    var evt = this.supportTouch ? e.touches[0] : e;\r\n    var coverPos = this.canvas.getBoundingClientRect();\r\n    var pageScrollTop = document.documentElement.scrollTop || document.body.scrollTop;\r\n    var pageScrollLeft = document.documentElement.scrollLeft || document.body.scrollLeft;\r\n    var mouseX = evt.pageX - coverPos.left - pageScrollLeft;\r\n    var mouseY = evt.pageY - coverPos.top - pageScrollTop;\r\n    this.ctx.beginPath();\r\n    this.ctx.fillStyle = '#FFFFFF';\r\n    this.ctx.globalCompositeOperation = \"destination-out\";\r\n    this.ctx.arc(mouseX, mouseY, this.defaultOptions.radius * 2, 0, 2 * Math.PI);\r\n    this.ctx.fill();\r\n}\r\n;\r\nfunction _endHandler(e) {\r\n    e.preventDefault();\r\n    if (this.defaultOptions.callback && typeof this.defaultOptions.callback === 'function')\r\n        this.calcRatio(this.defaultOptions.callback);\r\n    // if (this.defaultOptions.callback && typeof this.defaultOptions.callback === 'function') calcRatio.call(this,this.ctx, this.defaultOptions.callback, this.defaultOptions.ratio);\r\n    this.canvas.removeEventListener(this.events[1], this.moveEventHandler, false);\r\n    document.removeEventListener(this.events[2], this.endEventHandler, false);\r\n}\r\n;\r\n","dts":{"name":"/Users/tian/Desktop/wheel/happy-gua/main.d.ts","writeByteOrderMark":false,"text":"interface Options {\r\n    ele?: string;\r\n    radius?: number;\r\n    coverColor?: string;\r\n    coverText?: string;\r\n    coverPic?: string;\r\n    ratio?: number;\r\n    callback?: Function;\r\n}\r\nexport default class HappyGua {\r\n    canvas: any;\r\n    ctx: any;\r\n    wrapEle: any;\r\n    innerEle: any;\r\n    canvasW: number;\r\n    canvasH: number;\r\n    supportTouch: boolean;\r\n    events: any[];\r\n    startEventHandler: Function;\r\n    moveEventHandler: Function;\r\n    endEventHandler: Function;\r\n    defaultOptions: Options;\r\n    constructor(options: Options);\r\n    init(options: any): void;\r\n    createCanvas(): void;\r\n    eventDetect(): void;\r\n    listenStart(): void;\r\n    clearAll(): void;\r\n    calcRatio(callback: any): void;\r\n}\r\nexport {};\r\n"}}
